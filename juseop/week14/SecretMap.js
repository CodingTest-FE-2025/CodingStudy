/**
 * 비밀지도
 * 1. 지도는 한변의 길이가 n인 정사각형 배열 형태, 각 칸은 "공백"("") 또는 "벽"("#")로 이루어짐.
 * 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 지도1, 2 중 벽인 부분과 공백인 부분은 전체 지도에서도 벽이고 공백이다.
 * 3. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.
 * 4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백부분을 0으로 부호화 했을 때 얻어지는 이진수에 해당하는 값의 배열
 * 5. 원래의 비밀지도를 해독하여 "#", 공백으로 구성된 문자열 배열로 출력.
 *
 * 입출력 예
 * n = 5, arr1 = [9, 20, 28, 18, 11], arr2 = [30, 1, 21, 17, 28] => ["#####", "# # #", "### #", "# ##", "#####"]
 * n = 6, arr1 = [46, 33, 33, 22, 31, 50], arr2 = [27, 56, 19, 14, 14, 10] => ["######", "### #", "## ##", " # # ", "#####", "### #"]
 */

// 일단 주어진 배열을 이진수로 변환한 후, 각 자리수를 비교하여 1이면 "#"을, 0이면 " "을 넣어주면 된다.
// 이진수로 변환할 때, padStart를 사용하여 n자리로 맞춰주고, split을 사용하여 각 자리수를 배열로 나누어준다.
function solution(n, arr1, arr2) {
  let answer = [];
  for (let i = 0; i < n; i++) {
    let nemo1 = arr1[i].toString(2).padStart(n, "0").split("");
    let nemo2 = arr2[i].toString(2).padStart(n, "0").split("");
    let result = nemo1
      .map((x, y) => (x === "1" || nemo2[y] === "1" ? "#" : " "))
      .join("");
    answer.push(result);
  }
  return answer;
}

//1. toString(2) : 2진수로 변환
//2. padStart(n, "0") : n자리로 맞춰주기 위해 앞에 0을 채워줌
//3. split("") : 각 자리수 문자열을 배열로 나눔
//4. map() : 각 자리수를 비교하여 1이면 "#"을, 0이면 " "을 넣어줌
//5. join("") : 배열을 문자열로 변환

//각 정수를 이진수 문자열로 변한
// 두 배열의 같은 인덱스끼리 OR연산을 통해 지도에 벽이 있는지 없는지 판단
// 벽이 있는 자리(1)에는 "#"을, 없는 자리(0)에는 " "을 넣어줌
