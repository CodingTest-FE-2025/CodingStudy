// 작업이 완료되는 날짜를 계싼하고 여러작업을 묶어서 한번에 배포되는 작업수를 계산.
// 문제를 더 쉽게 이해하기

// 1. 작업과 속도
// progresses 배열: 각 작업의 현재 진행 상태 (%로 표현).
// speeds 배열: 하루에 각 작업이 얼마나 진행되는지 (%로 표현).

// 2. 배포 조건
// 각 작업은 100%가 되어야 배포 가능.
// 앞의 작업이 끝나지 않으면 뒤의 작업이 배포되지 못함(함께 배포됨).

// 목표
// 작업들이 배포될 때, 한 번에 몇 개씩 배포되는지 세어서 배열로 반환.

// 각 작업이 완료되는데 걸리는 날짜 계산하기
// 각 작업의 남은 작업량을 속도로 나누면 며칠이 필요한지 계산할 수 있어요.

// 작업 1: 남은 작업량 = 100−93=7
// 100−93=7, 속도 = 1 → 걸리는 날 =7/1=77/1=7
// 작업 2: 남은 작업량 =100 −30=70
// 100−30=70, 속도 = 30 → 걸리는 날 = 70/30≈2.34→3
// 작업 3: 남은 작업량 = 100−55=45, 속도 = 5 → 걸리는 날 = 45/5=9
// 그래서 걸리는 날: [7, 3, 9]

// 배포 그룹 계산하기
// 작업은 순서대로 처리되기 때문에, 앞의 작업보다 뒤의 작업이 빨리 끝나도 기다려야 해요.

// 첫 번째 작업이 끝나는 날: 7
// 두 번째 작업: 끝나는 날 = 3 (하지만 첫 번째 작업보다 느림 → 배포 대기)
// 세 번째 작업: 끝나는 날 = 9 (첫 번째 작업과 함께 배포 가능)
// 배포 결과:

// 첫 번째 배포: [7, 3] → 2개 배포
// 두 번째 배포: [9] → 1개 배포
// 최종 결과: [2, 1]

function solution(progresses,speeds){
    //1. 각 작업의 남은 일수를 계산
    const days = progresses.map((progress, i)=>
    Math.ceil((100-progress)/speeds[i]));

    const result = [];//배포 그룹별 작업 수를 저장할 배열
    let MaxDay = days[0]; // 현재 그룹에서 가장 오래 걸리는 작업의 남은 일수
    let count = 0; // 현재 그룹에 포함된 작업 수

    for (let i=0; i<days.length; i++){
        if(days[i]<=MaxDay){//현재 작업이 이전 그룹과 함께 배포 가능
            count++;
        }else{
            //새로운 그룹 시작
            result.push(count);
            count=1;//현재 작업 포함
            MaxDay = days[i];// 새로운 그룹의 기준일 갱신
        }
    }
result.push(count);
return result;
}
