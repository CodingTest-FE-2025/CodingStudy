/**
 * 1. 올바른 괄호의 조건
 * 열린괄호는 반드시 짝을이루는 괄호가 있어야한다.
 * 문자열이 진행되는 동안 닫힌 괄호가 열린괄호보다 먼저 나오면 안된다.
 * 최종적으로 모든 열린 괄호는 닫힌 괄호와 매칭되어야 하며, 남는 괄호가 없어야한다.
 * 2. 제한사항
 * 문자열의 길이는 최대 100,000으로, 시간복잡도가 중요한 문제이다.
 * o(n)으로 해결할 수있는 효율적인 알고리즘이 필요하다.
 */

/**
 * 해결방법
 * 1. 카운터를 사용하여 열린 괄호와 닫힌 괄호를 추적하고.
 * 문자열을 왼쪽에서 오른쪽으로 순회하며 '('가 나오면 카운터를 증가시키고, ')'가 나오면 카운터를 감소시킨다.
 * 카운터가 음수가 되는 순간 '('보다 ')'가 더많이 나온것으로, 즉시 false를 반환시킨다.
 * 2. 최종확인
 * 문자열을 모두 순회한 후 , 카운터가 0이면 모든 열린 괄호가 닫힌 괄호와 매칭되었다는 의미로 true를 반환
 * 카운터가 0이 아니면 남은괄호가 있다는 뜻으로 false를 반환
 */

function solution(s){
    let counter= 0;

    for (const chart of s){
        if (chart === '('){
            counter++;//열린 괄호 증가
        }else{
            counter--;//닫힌 괄호 감소
        }
    //중간에 닫힌 괄호가 열린 괄호보다 많아지면 올바르지 않음
    if(counter < 0){
        return false;
    }
    }
    return counter === 0;
}

/**
 * counter 변수 : 열린 괄호 '('를 만나면 카운터를 증가시키고 닫힌괄호 ')'를 만나면 카운터를 감소시킨다.
 * if(counter < 0) 조건: 문자열 순회를 진행하는 중간에 닫힌 괄호가 열린 괄호보다 많아지면 즉시 false를 반환한다.
 * 최종결과 : 순회가 끝난후 counter ==-0 이면 올바른 괄호, 그렇지 않으면 남은 괄호가 있어 false를 반환한다.
 */

/**
 * 주요 포인트
 * 효율적인 0(n) 알고리즘으로 대량의 문자열 입력에도 처리 속도가 빠르다.
 * 닫힌 괄호가 열린 괄호보다 많은 경우를 즉시 탐지하여 불필요한 연산을 줄입니다.
 */

//for (const element of iterable){
    //반복 실행할 코드
//}
/**
 * iterable: 반복가능한 개체 . 예를들어 배열, 문자열, set, Map 등이 있다.
 * element: 반복 중에 현재요소를 나타내는 변수
 * 문자열은 반복 가능한(iterable) 객체로 간주되며 for...of를 사용하면 문자열의 각 문자를 순회할 수 있다.
 * 
 */