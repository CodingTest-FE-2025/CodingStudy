DFS (깊이 우선 탐색)
개념:
DFS는 한 방향으로 최대한 깊게 들어간 후, 더 이상 진행할 수 없을 때 이전 분기점으로 돌아와 다른 경로를 탐색하는 방식입니다.
즉, 한 노드에서 갈 수 있는 다음 노드를 선택하여 끝까지 탐색한 후, 돌아오면서 다른 분기를 탐색합니다.

구현 방법:
일반적으로 재귀 함수를 사용하거나 스택(stack)을 이용해서 구현합니다.

재귀 방식: 함수 내부에서 자기 자신을 호출하면서 탐색 깊이를 증가시킵니다.
스택 방식: 직접 스택 자료구조를 사용하여 현재 노드의 인접 노드를 스택에 쌓아 놓고 탐색합니다.
특징:

메모리 사용: 일반적으로 방문해야 할 노드가 많지 않다면 메모리 사용량이 적습니다.
경로 탐색: 모든 경로를 탐색하는 데 유리합니다. 특히, 해답이 많거나 조건에 맞는 해답을 찾기 위해 모든 경우를 고려할 때 유용합니다.
단점:
최단 경로를 보장하지 않습니다.
깊은 재귀 호출로 인해 스택 오버플로우(stack overflow)가 발생할 수 있습니다.
예시:
DFS를 이용하면 특정 조건에 맞는 해답을 찾거나, 미로 찾기 문제에서 출발점부터 도착점까지 가능한 모든 경로를 탐색할 수 있습니다.

BFS (너비 우선 탐색)
개념:
BFS는 시작 노드에서부터 가까운 노드부터 탐색하며, 점차 멀어지는 방향으로 진행하는 방식입니다.
즉, 시작점으로부터 1단계, 2단계, 3단계 순으로 같은 레벨에 있는 노드를 모두 방문한 후 다음 레벨로 넘어갑니다.

구현 방법:
일반적으로 큐(queue)를 사용하여 구현합니다.

큐 방식: 시작 노드를 큐에 넣고, 큐에서 하나씩 꺼내어 인접한 노드를 큐에 추가하는 과정을 반복합니다.
특징:

최단 경로 보장: 시작점에서 목표 노드까지의 최단 경로를 찾을 때 유리합니다.
메모리 사용: 모든 레벨의 노드를 저장해야 하므로 DFS에 비해 메모리 사용량이 많을 수 있습니다.
단점:
탐색 범위가 넓은 경우 큐의 크기가 커져 메모리 사용량이 급증할 수 있습니다.
예시:
BFS는 최단 경로를 구하는 문제(예: 미로에서 최단 거리 찾기, 최단 변환 경로 등)에 많이 사용됩니다.

요약
DFS: 한 방향으로 깊게 들어가서 모든 경로를 탐색하는 방식.
→ 재귀나 스택을 사용. 메모리 효율이 좋으나 최단 경로를 보장하지 않음.

BFS: 시작점에서부터 가까운 노드를 우선적으로 탐색하는 방식.
→ 큐를 사용. 최단 경로를 보장하지만, 메모리 사용량이 많을 수 있음.
