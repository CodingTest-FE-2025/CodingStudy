function solution(maps) {
  /**
   * 맵
   * [1,0,1,1,1]
   * [1,0,1,0,1]
   * [1,0,1,1,1]
   * [1,1,1,0,1]
   * [0,0,0,0,1]
   *
   * 맵 xy 좌표, n(세로개수), m(가로개수)
   * [(0,0) -> m1, (0,1), (0,2), (0,3), (0,4)] -> n1
   * [(1,0) -> m2, (1,1), (1,2), (1,3), (1,4)] -> n2
   * [(2,0) -> m3, (2,1), (2,2), (2,3), (2,4)] -> n3
   * [(3,0) -> m4, (3,1), (3,2), (3,3), (3,4)] -> n4
   * [(4,0) -> m5, (4,1), (4,2), (4,3), (4,4)] -> n5
   */
  const n = maps.length;
  const m = maps[0].length;

  /**
   * 큐 queue
   * 선입선출 구조 -> 먼저 들어간 데이터가 먼저 나옴
   * push() , shift() 사용
   * push() -> 배열의 끝에 추가
   * shift() -> 배열의 첫번째 요소 제거
   *
   * 시작 위치(0,0)를 큐에 넣고 시작
   */
  let queue = [[0, 0]];

  /**
   * 상하좌우 계산
   * 상 [dx[0], dy[0]] -> (-1,0)
   * 하 [dx[1], dy[1]] -> (1,0)
   * 좌 [dx[2], dy[2]] -> (0,-1)
   * 우 [dx[3], dy[3]] -> (0,1)
   */
  const dx = [-1, 1, 0, 0];
  const dy = [0, 0, -1, 1];

  /**
   * queue에 값이 있으면 반복
   */
  while (queue.length > 0) {
    /**
     * shift() 사용 -> queue 맨 앞 좌표를 밖으로 꺼냄 (=버림)
     * 좌표를 버림과 동시에 x, y에 각각 저장
     */
    const [x, y] = queue.shift();

    /**
     * 이동할수 있는 방향이 있으면 해당 좌표를 queue에 추가
     * 예1) 우측으로 이동할수 있고, 하단으로 이동할수 있으면 queue에 2개 좌표 추가
     * 예2) 우측으로만 이동할수 있으면 queue에 1개 좌표 추가
     *
     * 상 하 좌 우 총 4번만 고정으로 반복
     */
    for (let k = 0; k < 4; k++) {
      /**
       * nx = nextX = 다음 이동할 가로(x) 좌표
       * ny = nextY = 다음 이동할 세로(y) 좌표
       *
       * dx 와 dy 를 대입하여 이동할 좌표를 계산
       * 예1) (2,3)에서 상단으로 이동하면 (1,3)이 되므로 nx = 1 (2-1), ny = 3 (3+0)
       * 예2) (2,3)에서 하단으로 이동하면 (3,3)이 되므로 nx = 3 (2+1), ny = 3 (3+0)
       * 예3) (2,3)에서 좌측으로 이동하면 (2,2)이 되므로 nx = 2 (2+0), ny = 2 (3-1)
       * 예4) (2,3)에서 우측으로 이동하면 (2,4)이 되므로 nx = 2 (2+0), ny = 4 (3+1)
       */
      const nx = x + dx[k];
      const ny = y + dy[k];

      /**
       * 맵의 범위를 벗어나는지 확인 벗어니면 continue
       * nx가 0보다 작으면 맵 위로 벗어남
       * ny가 0보다 작으면 맵 왼쪽으로 벗어남
       * nx가 n 이상이면 맵 아래로 벗어남 (n은 세로 개수)
       * ny가 m 이상이면 맵 오른쪽으로 벗어남 (m은 가로 개수)
       *
       * 중요! continue 를 만나면 현재 코드는 더이상 실행하지 않고 다음 반복을 실행하도록 함
       * 그래야 시간복잡도를 줄일 수 있음
       */
      if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;

      /**
       * 벽이거나 이미 방문한 곳인지 확인
       * 방문할 곳이 벽이면 0
       * 방문할 곳이 2이상이면 이미 방문한 곳 (이유 : 방문하면 +1을 하므로 2이상이면 이미 방문한 곳)
       *
       * 방문해야 하는 곳이 1이 아니면 continue
       */
      if (maps[nx][ny] !== 1) continue;

      /**
       * 방문할 곳에 현재 좌표에있는 위치값(?) +1
       */
      maps[nx][ny] = maps[x][y] + 1;

      /**
       * 방문할 곳의 좌표를 queue에 추가
       */
      queue.push([nx, ny]);
    }
  }

  /**
   * while문이 끝나면 목적지에 도착했는지 확인
   * 목적지가 1이면 도착하지 못함 -1 리턴
   * 목적지가 1이 아니면 최단거리 리턴
   *
   * n-1과 m-1 인 이유는 배열은 0부터 시작하므로..
   */
  if (maps[n - 1][m - 1] === 1) {
    return -1;
  } else {
    return maps[n - 1][m - 1];
  }
}

console.log(
  solution([
    [1, 0, 1, 1, 1],
    [1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1],
    [1, 1, 1, 0, 1],
    [0, 0, 0, 0, 1],
  ])
);
